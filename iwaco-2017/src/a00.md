## Algebraic Data Types

```rust
#[derive(Clone)]
enum BinaryTree { Leaf(i32), Node(Box<BinaryTree>, i32, Box<BinaryTree>) }

fn sample_tree() -> BinaryTree {
    let l1 = Box::new(BinaryTree::Leaf(1));
    let l3 = Box::new(BinaryTree::Leaf(3));
    let n2 = Box::new(BinaryTree::Node(l1, 2, l3));
    let l5 = Box::new(BinaryTree::Leaf(5));
    BinaryTree::Node(n2, 4, l5)
}
```

. . .

```art
CONCRETE:                                  ABSTRACT:     .---.
                                                      .--| 4 |--.
                                                      |  '---'  |
                                                    .-+-.     .-+-.
                                                  .-| 2 |--.  | 5 |
(STACK)           (HEAP)                          | '---'  |  '---'
                                                +-+-+    +-+-+
                                                | 1 |    | 3 |
sample_tree:                                    +---+    +---+

  .------.
  |Node: |        .------.     .------.     .------.     .------.
  | Box --------->|Node: |  .->|Leaf: |  .->|Leaf: |  .->|Leaf: |
  |      |        | Box ---+   |      |  |  |      |  |  |      |
  | (4)  |        |      |     | (1)  |  |  | (3)  |  |  | (5)  |
  |      |        | (2)  |     |      |  |  |      |  |  |      |
  | Box -----.    |      |     |      |  |  |      |  |  |      |
  |      |   |    | Box ----.  |      |  |  |      |  |  |      |
  '------'   |    |      |  |  |      |  |  |      |  |  |      |
             |    '------'  |  '------'  |  '------'  |  '------'
             |              '------------'            |
             '----------------------------------------'
```

>- Syntax: `enum` declares an algebraic (sum-of-product) data type
>- Boxing of values is explicit (âˆ´ all variants of an enum have same size)
>- `Box<T>` is an *owning* reference to heap-allocated data of type `T`

## Ownership

``` {.rust}
enum BinaryTree { Leaf(i32), Node(Box<BinaryTree>, i32, Box<BinaryTree>) }
```

>- `match` *moves* input to `Leaf(n)` or `Node(l, n, r)` as appropriate
>- `*expr` dereferences; here, moves tree *out* of box to local stack slot
>- `tree_weight` signature: pass-by-value + move semantics = arguments consumed

```rust
fn tree_weight(t: BinaryTree) -> i32 {
    match t {
        BinaryTree::Leaf(payload) => payload,
        BinaryTree::Node(left, payload, right) => {
            tree_weight(*left) + payload + tree_weight(*right)
        }
    }
}
```

## Arguments Consumed

``` {.rust .compile_error}
fn tree_weight(t: BinaryTree) -> i32 { ... }

fn consume_semantics() {
    let t = sample_tree();
    let w1 = tree_weight(t);
    let w2 = tree_weight(t);
    println!("w1: {} w2: {}", w1, w2);
}
```

. . .

``` {.terminal}
error[E0382]: use of moved value: `t`
  --> src/a00.rs:67:17
   |
66 |     tree_weight(t);
   |                 - value moved here
67 |     tree_weight(t);
   |                 ^ value used here after move
   |
   = note: move occurs because `t` has type `BinaryTree`,
           which does not implement the `Copy` trait
```

## Sending resources (`std::thread`)

<!--
```rust
#[test]
fn demo_send1() {
    use std::thread;
    use std::sync::mpsc::*;
```
-->
```rust
let (tx, rx) = channel(); // create transmitter/receiver pair
thread::spawn(move || match rx.recv() { // spawn A1, taking ownership of `rx`
    Ok(v) => {
        println!("A1 received {:?}", v)
    } // (end of scope for `v`; its resources are automatically cleaned up.)
    Err(err) => println!("A1 receive failure {:?}", err),
});
let t1 = tx.clone();
thread::spawn(move || { // spawn A2, taking ownership of `t1`
    let mut v = Vec::new(); v.push('a'); v.push('b'); v.push('c');
    t1.send(v).expect("A2 send failure");
});
thread::spawn(move || { // spawn A3, taking ownership of `tx`
    let v = vec!['1', '2', '3'];
    tx.send(v).expect("A3 send failure");
});
```
<!--
```rust
}
```
-->

>- Syntax: `|arg, ...| expr` (incl. `|| { expr; ... }`) are *closures*
>- `move |arg, ...| { expr; ... }` captures free variables by transferring ownership ("moving")
>- `println!` and `vec!` are macros (typesafe printf; Vec construction sugar)
>- Destruction 1: at end of scope for `v`, backing buffer and contents are reclaimed
>- Destruction 2: when `rx`, `t1` & `tx` have reached end of respective scopes, resources for channel reclaimed

## Sending resources between threads

```art
|(tx, rx) = channel();
| :    '---------------------------------------------.
| |[txa]                                             |[move_rx]
+-|----------------------------------------------.   rx
| '----.                                         |   :
|      |                                         |   :
| t1 = tx.clone()                                |   |[rxa]
|  '--------------------------------.            |   |
|      :                            |[m_t1]      |   |
+------|--------------------------. t1           |   |
|      |                          | |[t1a]       |   |
|      |[txb]                     | :            |   |
|      tx                         | |            |   |
|       '------------.            | |            |   |
|                    |[m_t2]      | |            |   |
+------------------. tx           | |            |   |
|                  | |[t2a]       | |            |   |
|                  | | v = Vec    | | v = Vec    |   |
|                  | | v.push('1')| | v.push('a')|   +
|                  | | v.push('2')| | v.push('b')|    \
|                  | | v.push('3')| | v.push('c')|     \
|                  | :            | |            |      \
|                  | tx.send(v)   | t1.send(v)   |       \
|                  |         |    |         |    |        \
|                  |         |    |         '------.       \
|                  |         |    |              | |[m_v1]  +
|                  |         '---------------------+        |
|                  |              |  [m_v2]      |  \       |
|                  |              |              | Ok(v) = rx.recv()
|                  |              |              | println!("A1 received {:?}", v)
|                  |              |              |
[move_rx]: stroke="orange" stroke-width="10"
[m_t1]:  stroke="orange" stroke-width="10"
[m_t2]: stroke="orange" stroke-width="10"
[m_v1]: stroke="orange" stroke-width="10"
[m_v2]: stroke="orange" stroke-width="10"
[rxa]: stroke="blue"
[txa]: stroke="blue"
[txb]: stroke="blue"
[t1a]: stroke="blue"
[t2a]: stroke="blue"
```

>- `rx`, `t1`, `tx`, and each `v` are all *moved* from one thread to another.
>- `t1` is *cloned* from `tx`; if we moved `tx` into middle subthread,
   it would not be available for left subthread.

## Move semantics alone: insufficient

### We are computer scientists

. . .

> We can solve any problem by introducing an extra level of indirection

-- David J. Wheeler

. . .

We need references

Distinguish:

>- ownership transfer, versus
>- lending access temporarily

## Importance of Ownership

Ownership enables:       which removes:
----------------------   -------------------------------------------
RAII-style destructors   source of memory leaks (or fd leaks, etc)
no dangling pointers     many resource management bugs
no data races            many multithreading heisenbugs
----------------------   -------------------------------------------

. . .

> Do I need to take ownership here, accepting the associated
> resource management responsibility? Would temporary
> access suffice?

. . .

Good developers ask this already!

Rust forces function signatures to encode the answers

(and they are checked by the compiler)


## Sharing Data

Pointers: Perhaps the Pandora's Box of Computer Science

>- `&mut T`, `&T`
>- (plus library reference types: `Box<T>`, `Cow<T>`, `Rc<T>`, ...)
>- `T` above ranges over both so-called "sized" and "unsized" types
>- Sized: `&char`, `&mut Vec<u8>`, `&[i32; 16]`
>- Unsized: `&str`, `&mut [u8]`, `&Fn() -> i32`

## Why multiple `&`-reference types? {.center}

 * Distinguish *exclusive* access from *shared* access

 * Enables **safe**, **parallel** API's

. . .

----------------- -------- -------------
Ownership         `T`
Exclusive access  `&mut T` ("mutable")
Shared access     `&T`     ("read-only")
----------------- -------- -------------

. . .

A `&T` provides limited access; cannot call methods that require
ownership or exclusive access to `T`

. . .

A `&mut T` provides *temporary* exclusive access; even the original
owner cannot mutate the object while you have the reference

. . .

But you cannot claim ownership of `T` yourself via `&mut T`, unless
you *swap* in another `T` to replace the one you are taking (a coding
pattern in Rust).


## Demo References

## Sharing resources (`rayon`)

<!--
```rust
#[test]
fn demo_send2() {
    use rayon;
    use std::sync::mpsc::*;
```
-->
```rust
let temp_data = vec!['a', 'b', 'c', '1', '2', '3'];
rayon::scope(|s| {
    let (tx, rx) = channel(); // create transmitter/receiver pair
    s.spawn(move |_s| { // spawn A1, taking ownership of `rx`
        match rx.recv() {
            Ok(v) => println!("A1 received {:?}", v),
            Err(err) => println!("A1 receive failure {:?}", err),
        }
    });
    let data: &[char] = &temp_data; // (N.B. assigned type is *not* `&Vec`)
    let t1 = tx.clone();

    // spawn A2, taking ownership of `t1` (and a copy of `data`)
    s.spawn(move |_s| t1.send(&data[0..4]).expect("A2 send failure"));

    // spawn A3, taking ownership of `tx` (and a copy of `data`)
    s.spawn(move |_s| tx.send(&data[2..6]).expect("A3 send failure"));

}); // (`rayon::scope` waits here until all `s.spawn`'ed threads finish)
```
<!--
```rust
}
```
-->

## Sharing resources between threads

```art
|temp_data: ---------------------------------------------------------.
|                                  [temp_data]                       |
|(tx, rx) = channel();                                               |
| :    '---------------------------------------------.               v
| |[txa]                                             |[move_rx]     +------+
+-|----------------------------------------------.   rx         .-->|      |    -.
| '----.                                         |   :          |   | 'a'  |     |
|      |                                         |   |          :   |      |     |<-.
|      |                                         |   :          +   | 'b'  |     |  :
| t1 = tx.clone()                                |   |[rxa]    /|   |      | -.  |  |
|  '--------------------------------.            |   |        / :   | 'c'  |  |  |  |
|      :                            |[m_t1]      |   |       /  +   |      |  |  |  |
+------|--------------------------. t1 , data -----=--------'  /    | '1'  |  | -'  |
|      |                          | |[t1a]       |   |  [d1]  /     |      |  |<-.  |
|      |[txb]                     | :            |   :       /      | '2'  |  |  :  |
|      tx                         | |            |   |[rxb] /       |      |  |  |  |
|       '------------.            | |            |   :     /        | '3'  | -'  |  |
|                    |[m_t2]      | |            |   |    /         |      |     |  |
+------------------. tx , data ------------=-------------'          +------+     |  |
                   | |[t2a]       | |            |   |  [d2]                     |  |
                   | |            | |[t1b]       |   :[rxc]                      |  |
                   | |            | :            |   |                           :  |
                   | | s --------------------------------------------------------'  |
                   | |    [s2]    | :            |    \                             |
                   | |            | |[t1c]       |     \[rxd]                       :
                   | :            | |   s ------------------------------------------'
                   | tx.send(s)   | t1.send(s)   |       \   [s1]
                   |         |    |         |    |        \
                   |         |    |         '------.       \
                   |         |    |              | |[m_s1]  +
                   |         '---------------------+        |[rxe]
                   |              |  [m_s2]      |  \       :
                   |              |              | Ok(s) = rx.recv()
                   |              |              | println!("A1 received {:?}", s)
                   |              |              |
                   |              |              |
+------------------+--------------+--------------+
|
[move_rx]: stroke="orange" stroke-width="10"
[m_t1]:  stroke="orange" stroke-width="10"
[m_t2]: stroke="orange" stroke-width="10"
[m_s1]: stroke="blue" stroke-width="10"
[m_s2]: stroke="blue" stroke-width="10"
[rxa]: stroke="blue"
[rxb]: stroke="blue"
[rxc]: stroke="blue"
[rxd]: stroke="blue"
[rxe]: stroke="blue"
[txa]: stroke="blue"
[txb]: stroke="blue"
[t1a]: stroke="blue"
[t1b]: stroke="blue"
[t1c]: stroke="blue"
[t2a]: stroke="blue"
[temp_data]: stroke="black"
[d1]: stroke="black"
[d2]: stroke="black"
[s1]: stroke="black"
[s2]: stroke="black"
```

>- `rx`, `t1`, `tx` still moved from one thread to another.
>- `data` is shared reference to character slice: freely copyable
>- The `s`'s represent the subslices `&data[0..4]` and `&data[2..6]`
>- (Safe for subslices of shared slice to overlap!)

## The `Send` trait


## `Send` is focused on ownership transfer

But we already know that move semantics alone does not suffice

(We need our references!)

## The `Sync` trait


## Title

Aliasing, Capabilities, and Ownership in Rust

Rust is a new systems programming language providing fast, memory-safe, data-race-free multi-threaded code. Rust has adopted many ideas from programming language research: Its affine type system has ownership and controlled aliasing at the foundation.

This demo will present Rust's ownership and borrowing system at a high level, discuss how we ensure data-race freedom, and explore the different ways that Rust encodes "capabilities" into the language and its libraries.

## Hello World

Hit the 'c' key many times.

```art
    |
    |
    |
    |
    | ----------------.       
    | [t1]             \      
    |                   \     
    | ---.               \    
    | [t2]\               \   
    |      \               \  
    |       +               + 
    |       |               | 
    |
    |  .-. +-----------------+ .-.
    |  | | |                 | | |
    |  '-' +-----------------+ '-'
    |  [a]    [c]              [b]
    |       |               |
    |       :               :
    |       :               :
    |       :               :
    |       :[t2r]          :[t1r]

[t1]: stroke="#00D000"
[t2]: stroke="#00A000"
[t1r]: stroke="#00D000"
[t2r]: stroke="#00A000"
[a]: stroke="none", fill="blue"
[b]: fill="none", stroke="none"
[c]: stroke="#BB0000"
```

<script>
var slide = document.getElementById("hello-world");
var svg = slide.getElementsByTagName("svg")[0];
var s = Snap(svg);

// s.text("50%", "50%", "Snap Tutorial").attr({
//     font: "300 100px Source Sans Pro",
//     textAnchor: "middle",
//     fill: "#fff"
// });

var a_elem = s.select("#a");
var b_elem = s.select("#b");
var c_elem = s.select("#c");

var t1 = s.g(s.select("#t1"), s.select("#t1r"));
var t2 = s.g(s.select("#t2"), s.select("#t2r"));

t1.attr("stroke", "#FFD000");
t2.attr("stroke", "#FFDA00");

var c_x_final = c_elem.getPointAtLength(0).x;
var c_y_final = c_elem.getPointAtLength(0).y;

t1.transform("translate(300)");
t2.transform("translate(300)");
c_elem.transform("translate("+ -c_x_final + "," + -c_y_final +")");

var a_x = a_elem.getPointAtLength(0).x;
var b_x = b_elem.getPointAtLength(0).x;
var a_y = a_elem.getPointAtLength(0).y;
var b_y = b_elem.getPointAtLength(0).y;
var delta_x = b_x - a_x;
var delta_y = b_y - a_y;

var clicks = 0;
var dx = 0;
var dy = 0;

var transition = function() {
    clicks += 1;
    switch (clicks) {
        case 1: {
            // reveal thread 1
            t1.animate({transform: ""}, 1000);
            break;
        }
        case 2: {
            // reveal thread 2
            t2.animate({transform: ""}, 1000);
            break;
        }
        case 3: {
            // install the channel
            c_elem.animate({transform: ""}, 1000);
            break;
        }
        default: {
            dx = (delta_x * (clicks % 2));
            dy = (delta_y * (clicks % 2));
            a_elem.animate({transform: "translate("+dx+","+dy+")"}, 1000);
            break;
        }
    }
};

window.addEventListener("keypress", function(evt) {
    console.log("keyup key: " + evt.key);
    if (evt.key == "c") {
        transition();
    }
}, false);

s.click(transition);
</script>

## Demo


```rust
use rayon;
use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc::{channel};

#[derive(Debug)]
struct Ball(&'static str);

fn actor(a: &str, the_ball: Option<Ball>, tx: Sender<Ball>, rx: Receiver<Ball>) {
    if let Some(ball) = the_ball {
        match tx.send(ball) {
            Ok(()) => {}
            Err(err) => {
                println!("Send failure {:?} on {}", err, a);
                return;
            }
        }
    }
    let mut ball;
    for i in 0..100 {
        match rx.recv() {
            Ok(received_ball) => { ball = received_ball; }
            Err(err) => {
                println!("Receive failure {:?} on {} iter {}", err, a, i);
                break;
            }
        }
        match tx.send(ball) {
            Ok(()) => {}
            Err(err) => {
                println!("Send failure {:?} on {} iter: {}", err, a, i);
                break;
            }
        };
    }
    println!("Done with {}", a);
}

#[test]
fn main() {
    rayon::scope(|s| {
        let (tx1, rx1) = channel();
        let (tx2, rx2) = channel();
        println!("Spawn Actor 1");
        s.spawn(|_s| { actor("Actor 1", Some(Ball("O")), tx1, rx2); });
        println!("Spawn Actor 2");
        s.spawn(|_s| { actor("Actor 2", None, tx2, rx1); });
    });
}
```
