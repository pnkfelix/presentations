% Aliasing, Capabilities, and Ownership in Rust
% Felix Klock (`@pnkfelix`), Mozilla
% <kbd class="key">space</kbd>: next slide; <kbd class="key">shift</kbd> <kbd class="key">space</kbd>: prev slide; <kbd class="key">esc</kbd>: overview; arrows&nbsp;navigate <a href="TODO"><code>http://url_todo</code></a>

## What is Rust?

### New programming language

>- (... and ecosystem, and development community)

### Emphasizing control, safety, and speed

>- (... *especially* when it comes to concurrency)

### Low-level hacking without fear of segfaults nor data races

> - or more simply: "Hack without Fear"

## Why ...?

## Why use Rust? { .big_text data-transition="fade-out" }

> - Fast code, low memory footprint
> - Go from bare metal (assembly; C FFI) ...
  <div class="fragment">... to high-level (closures, generic containers) ...</div>
  <div class="fragment">with *zero cost* (no GC, unboxed closures, monomorphization); no runtime, cross-lang interop</div>
> - *Safety* and *Parallelism*

## Safety and Parallelism {.center}

### Safety

* No segmentation faults

* No undefined behavior

* No data races

### (Multi-paradigm) Parallelism

  * msg passing via channels

  * shared state (R/W-capabilities controlled via types)

  * use native threads... or scoped threads... or work-stealing...

## Algebraic Data Types

```rust
enum BinaryTree { Leaf(i32), Node(Box<BinaryTree>, i32, Box<BinaryTree>) }
fn sample_tree() -> BinaryTree {
    let l1 = Box::new(BinaryTree::Leaf(1));
    let l3 = Box::new(BinaryTree::Leaf(3));
    let n2 = Box::new(BinaryTree::Node(l1, 2, l3));
    let l5 = Box::new(BinaryTree::Leaf(5));
    BinaryTree::Node(n2, 4, l5) }
```

. . .

```art
CONCRETE:                                  ABSTRACT:      .---.
                                                      .---| 4 |---.
                                                      |   '---'   |
                                                    .-+-.       +-+-+
(STACK)           (HEAP)                          .-| 2 |--.    | 5 |
                                                  | '---'  |    +---+
                                                +-+-+    +-+-+
sample_tree:                                    | 1 |    | 3 |
                                                +---+    +---+
  .------.
  |Node: |        .------.     .------.     .------.     .------.
  | Box --------->|Node: |  .->|Leaf: |  .->|Leaf: |  .->|Leaf: |
  |      |        | Box ---+   |      |  |  |      |  |  |      |
  | (4)  |        |      |     | (1)  |  |  | (3)  |  |  | (5)  |
  |      |        | (2)  |     |      |  |  |      |  |  |      |
  | Box -----.    |      |     |      |  |  |      |  |  |      |
  '------'   |    | Box ----.  |      |  |  |      |  |  |      |
             |    '------'  |  '------'  |  '------'  |  '------'
             |              '------------'            |
             '----------------------------------------'
```

>- Syntax: `enum`{.rust} declares an algebraic (sum-of-product) data type
>- `Box<T>`{.rust} is an *owning* reference to heap-allocated data of type `T`{.rust}
>- Boxing of values is explicit (+ all variants of an enum have same size)

## Ownership

``` {.rust}
enum BinaryTree { Leaf(i32), Node(Box<BinaryTree>, i32, Box<BinaryTree>) }
```

>- `match`{.rust} *moves* input to `Leaf(n)`{.rust} or `Node(l, n, r)`{.rust} as appropriate
>- `*expr`{.rust} dereferences; here, moves tree *out* of box to local stack slot
>- `fn`{.rust} signature: pass-by-value + move semantics = args consumed

```rust
fn tree_weight(t: BinaryTree) -> i32 {
    match t {
        BinaryTree::Leaf(payload) => payload,
        BinaryTree::Node(left, payload, right) => {
            tree_weight(*left) + payload + tree_weight(*right)
        }
    }
}
```

## Arguments Consumed

``` {.rust .compile_error}
fn tree_weight(t: BinaryTree) -> i32 { ... }

fn consume_semantics() {
    let t = sample_tree();
    let w1 = tree_weight(t);
    let w2 = tree_weight(t);
    println!("w1: {} w2: {}", w1, w2);
}
```

. . .

``` {.terminal}
error[E0382]: use of moved value: `t`
  --> src/a00.rs:67:17
   |
66 |     tree_weight(t);
   |                 - value moved here
67 |     tree_weight(t);
   |                 ^ value used here after move
   |
   = note: move occurs because `t` has type `BinaryTree`,
           which does not implement the `Copy` trait
```

## Sending resources (`std::thread`{.rust})

<!--
```rust
use std::rc::Rc;
use std::thread;
use std::cell::{Cell, RefCell};

#[test]
fn demo_send1() {
```
-->
```rust
let (tx, rx) = channel(); // create transmitter/receiver pair
thread::spawn(move || match rx.recv() { // spawn A1, taking ownership of `rx`
                          Ok(v_end) => {
                              println!("A1 received {:?}", v_end)
                          } // (end of scope for `v_end`; automatic clean up.)
                          Err(err) => println!("A1 receive failure {:?}", err),
                   });
let t1 = tx.clone();
thread::spawn(move || { // spawn A2, taking ownership of `t1`
                       let mut v = Vec::new(); v.push('a'); v.push('b'); v.push('c');
                       t1.send(v).expect("A2 send failure");
                   });
thread::spawn(move || { // spawn A3, taking ownership of `tx`
                       let v = vec!['1', '2', '3'];
                       tx.send(v).expect("A3 send failure");
                   });
```
<!--
```rust
}
```
-->

>- Syntax: `|arg, ...| expr`{.rust} (incl. `|| { expr; ... }`{.rust}) are *closures*
>- `move |arg, ...| expr`{.rust} captures by ownership xfer ("moving")
>- `println!`{.rust} and `vec!`{.rust} are macros (typesafe printf; Vec building sugar)
>- Destruction 1: at scope end for `v_end`{.rust}, buffer + contents reclaimed
>- Destruction 2: at scope end for `rx`{.rust}, `t1`{.rust} + `tx`{.rust}, channel reclaimed

## Sending between threads

```art
|(tx, rx) = channel();
| :    '---------------------------------------------.
| |[txa]                                             |[move_rx]
+-|----------------------------------------------.   rx
| '----.                                         |   :
|      |                                         |   :
| t1 = tx.clone()                                |   |[rxa]
|  '--------------------------------.            |   |
|      :                            |[m_t1]      |   |
+------|--------------------------. t1           |   |
|      |                          | |[t1a]       |   |
|      |[txb]                     | |            |   |
|      tx                         | |            |   |
|       '------------.            | :            |   |
|                    |[m_t2]      | |            |   |
+------------------. tx           | |            |   |
|                  | |[t2a]       | |            |   |
|                  | | v = Vec    | | v = Vec    |   |
|                  | | v.push('1')| | v.push('a')|   +
|                  | | v.push('2')| | v.push('b')|    \
|                  | | v.push('3')| | v.push('c')|     \
|                  | :            | |            |      \
|                  | tx.send(v)   | t1.send(v)   |       \
|                  |         |    |         |    |        \
|                  |         |    |         '------.       \
|                  |         |    |              | |[m_v1]  +
|                  |         '---------------------+        |
|                  |              |  [m_v2]      |  \       |
|                  |              |              | Ok(v) = rx.recv()
|                  |              |              | println!("A1 received {:?}", v)
[move_rx]: stroke="orange" stroke-width="10"
[m_t1]:  stroke="orange" stroke-width="10"
[m_t2]: stroke="orange" stroke-width="10"
[m_v1]: stroke="orange" stroke-width="10"
[m_v2]: stroke="orange" stroke-width="10"
[rxa]: stroke="blue"
[txa]: stroke="blue"
[txb]: stroke="blue"
[t1a]: stroke="blue"
[t2a]: stroke="blue"
```

>- `rx`{.rust}, `t1`{.rust}, `tx`{.rust}, and each `v`{.rust} are all *moved* from one thread to another
>- `t1`{.rust} *cloned* from `tx`{.rust}; (if `tx`{.rust} moved to middle subthread, would not
   be available for left one)

## Not everything can be sent

```rust
fn demo_sendable() {
    let (tx, rx) = channel();
    let r1 = Rc::new(vec!['a', 'b', 'c', '1', '2', '3']);
    tx.send(r1.clone()).unwrap();
    let _r2 = rx.recv().unwrap();
    println!("r1: {:?}", r1);
}
```

. . .

(above is fine)

>- FYI: `Rc<T>`{.rust} is a reference-counted pointer to a heap-allocated `T`{.rust}
>- (Like `Box<T>`{.rust}, but with dynamically-tracked shared ownership
    rather than statically-tracked sole ownership)

## Not everything can be sent (really)

``` {.rust .compile_error}
fn demo_unsendable() {
    let (tx, rx) = channel();
    let r1 = Rc::new(vec!['a', 'b', 'c', '1', '2', '3']);
    thread::spawn(move || { let r2 = rx.recv().unwrap();
                            println!("received: {:?}", r2); });
    tx.send(r1.clone()).unwrap();
    println!("r1: {:?}", r1);
}
```

``` {.terminal}
error[E0277]: the trait bound `Rc<Vec<char>>: Send` is not satisfied
   --> src/a00.rs:405:5
    |
405 |     thread::spawn(move || {
    |     ^^^^^^^^^^^^^ `Rc<Vec<char>>` cannot be sent between threads safely
    |
    = help: the trait `Send` is not implemented for `Rc<Vec<char>>`
    = note: required because of the requirements on the impl of `Send`
            for `Receiver<Rc<Vec<char>>>`
    = note: required because it appears within the type
            `[closure@src/a00.rs:405:19: 410:6 Receiver<Rc<Vec<char>>>]`
    = note: required by `std::thread::spawn`
```

. . .

Will revisit these constraints a bit more later

Digression: talk about sharing for a moment

## Move semantics alone: insufficient

### We are computer scientists

. . .

> We can solve any problem by introducing an extra level of indirection

-- David J. Wheeler

. . .

We need references; allows distinguishing:

>- ownership transfer, versus
>- lending access temporarily

## Importance of Ownership

Ownership enables:       which removes:
----------------------   -------------------------------------------
RAII-style destructors   source of memory leaks (or fd leaks, etc)
no dangling pointers     many resource management bugs
no data races            many multithreading heisenbugs
----------------------   -------------------------------------------

. . .

> Do I need to take ownership here, accepting the associated
> resource management responsibility? Would temporary
> access suffice?

. . .

Good developers ask this already!

Rust forces function signatures to encode the answers

(and they are checked by the compiler)


## Sharing Data

Pointers: Perhaps the Pandora's Box of Computer Science

>- `&mut T`{.rust}, `&T`{.rust}
>- (plus library reference types: `Box<T>`, `Cow<T>`, `Rc<T>`, ...)
>- `T`{.rust} above ranges over both so-called "sized" and "unsized" types
>- Sized: `&char`{.rust}, `&mut Vec<u8>`{.rust}, `&[i32; 16]`{.rust}
>- Unsized: `&str`{.rust}, `&mut [u8]`{.rust}, `&Fn() -> i32`{.rust}

## Menagerie: `&T`{.rust}, `Box<T>`{.rust}, `Rc<T>`{.rust} etc

>- `T`{.rust}: owned instance of `T`{.rust}, stored inline (e.g. in stack frame or record)
>- `Box<T>`{.rust}: owned instance of `T`{.rust}, stored on heap (so `Box<T>`{.rust} itself is just a pointer)
>-  `&T`{.rust}: pointer to `T`{.rust}, but not owned. Extent is limited to some static scope (possibly
    a scope known only to function's caller).
>- `Rc<T>`{.rust}: ref-counted pointer to `T`; *shared ownership*. (At end of scope for
   our `Rc<T>`{.rust}, we *might* be responsible for resource cleanup.)

## Why multiple `&`-reference types? {.center}

 * Distinguish *exclusive* access from *shared* access

 * Enables **safe**, **parallel** API's

. . .

----------------- --------------- ---------------
Ownership         `T`{.rust}
Exclusive access  `&mut T`{.rust} ("mutable")
Shared access     `&T`{.rust}     ("read-only")
----------------- --------------- ---------------

. . .

A `&T`{.rust} provides limited access; cannot call methods that require
ownership or exclusive access to `T`{.rust}

. . .

A `&mut T`{.rust} provides *temporary* exclusive access; even the original
owner cannot mutate the object while you have the reference

. . .

But cannot claim ownership of `T`{.rust} yourself via `&mut T`{.rust}, unless
you *swap* in another `T`{.rust} to replace one you take (Rust coding
pattern)


## References and Slices

```rust
fn demo_references() {
    let v = vec!['a', 'b', 'c', '1', '2', '3'];
    let ref1 = &v[0..3];
    let ref2 = &v[3..6];
    let f1 = |i| println!("ref1[{}]: {:?}", i, ref1[i]);
    let f2 = |i| println!("ref2[{}]: {:?}", i, ref2[i]);
    f1(1);
    f2(2);
}
```

```art
    v -------------------------------------------------------------.
          [v]                                                      |(r)
                                                                   v
                                                                  +-------+
                                                               .- |       |
                                                           (r) |  | 'a'   |
    ref1 ---------=------------------------------------------->|  |       |
          [ref1]                                               |  | 'b'   |
                                                               |  |       |
                                                               '- | 'c'   |
                                                               .- |       |
                                                           (r) |  | '1'   |
    ref2 ---------=------------------------------------------->|  |       |
          [ref2]                                               |  | '2'   |
                                                               |  |       |
                                                               |  | '3'   |
                                                               '- |       |
                                                                  +-------+
[v]: stroke="black"
[ref1]: stroke="red"
[ref2]: stroke="red"
```

## `Rc<T>`{.rust} (shared ownership)

```rust
fn demo_refcounts() {
    let r1 = Rc::new(vec!['a', 'b', 'c', '1', '2', '3']);
    let r2 = r1.clone();
    let f1 = |i| println!("v[{}]: {:?}", i, r1[i]);
    let f2 = |i| println!("v[{}]: {:?}", i, r2[i]);
    f1(1);
    f2(2);
}
```

```art
                                          +------------+
    r1 ---------------------------------->| count: 2   |
        [r1]                              | Vec buf: --------------.
                                          |     len: 6 |           |
    r2 ---------------------------------->|     cap: 8 |           v
        [r2]                              +------------+          +-------+
                                                                  |       |
                                                                  | 'a'   |
                                                                  |       |
                                                                  | 'b'   |
                                                                  |       |
                                                                  | 'c'   |
                                                                  |       |
                                                                  | '1'   |
                                                                  |       |
                                                                  | '2'   |
                                                                  |       |
                                                                  | '3'   |
                                                                  |       |
                                                                  +-------+
[r1]: stroke="black"
[r2]: stroke="black"
```

## Is `&mut`{.rust} only way to encode mutation via reference?

. . .

(No!)

## Interior Mutability: `Cell`{.rust} + `RefCell`{.rust}

>- Both types have mutator methods that take `&self`{.rust} (*not* `&mut self`{.rust})
>- `Cell<T>`{.rust}: *move* values in+out (via swapping, or other methods that ensure cell remains sound, e.g. get/set if `T: Copy`{.rust})
>- `RefCell<T>`{.rust} provides refs to the `T`{.rust} it holds,
   but *dynamically* *enforces* the rules.
>- `RefCell::borrow()`{.rust} returns read-only `Ref`{.rust} (many-readers),
   and `panic!`{.rust}'s on outstanding mut-borrow (∴ no previous writers)
>- `RefCell::borrow_mut()`{.rust} returns read/write `RefMut`{.rust} (unique),
   and `panic!`{.rust}'s on any outstanding borrow 
   (∴ no previous readers or writers).

## Sharing resources (`rayon`)

<!--
```rust
use rayon;
use std::sync::mpsc::*;

#[test]
fn demo_send2() {
```
-->
```rust
let temp_data = vec!['a', 'b', 'c', '1', '2', '3'];
rayon::scope(|s| {
    let (tx, rx) = channel(); // create transmitter/receiver pair
    s.spawn(move |_s| { // spawn A1, taking ownership of `rx`
        match rx.recv() {
            Ok(v) => println!("A1 received {:?}", v),
            Err(err) => println!("A1 receive failure {:?}", err),
        }
    });
    let data: &[char] = &temp_data; // (N.B. assigned type is *not* `&Vec`)
    let t1 = tx.clone();

    // spawn A2, taking ownership of `t1` (and a copy of `data`)
    s.spawn(move |_s| t1.send(&data[0..4]).expect("A2 send failure"));

    // spawn A3, taking ownership of `tx` (and a copy of `data`)
    s.spawn(move |_s| tx.send(&data[2..6]).expect("A3 send failure"));

}); // (`rayon::scope` waits here until all `s.spawn`'ed threads finish)
```
<!--
```rust
}
```
-->

## Sharing resources between threads

```art
|temp_data: ---------------------------------------------------------.
|                                  [temp_data]                       |
|(tx, rx) = channel();                                               |
| :    '---------------------------------------------.               v
| |[txa]                                             |[move_rx]     +------+
+-|----------------------------------------------.   rx         .-->|      |    -.
| '----.                                         |   :          |   | 'a'  |     |
|      |                                         |   |          :   |      |     |<-.
|      |                                         |   :          +   | 'b'  |     |  :
| t1 = tx.clone()                                |   |[rxa]    /|   |      | -.  |  |
|  '--------------------------------.            |   |        / :   | 'c'  |  |  |  |
|      :                            |[m_t1]      |   |       /  +   |      |  |  |  |
+------|--------------------------. t1 , data -----=--------'  /    | '1'  |  | -'  |
|      |                          | |[t1a]       |   |  [d1]  /     |      |  |<-.  |
|      |[txb]                     | :            |   :       /      | '2'  |  |  :  |
|      tx                         | |            |   |[rxb] /       |      |  |  |  |
|       '------------.            | |            |   :     /        | '3'  | -'  |  |
|                    |[m_t2]      | |            |   |    /         |      |     |  |
+------------------. tx , data ------------=-------------'          +------+     |  |
                   | |[t2a]       | :            |   |  [d2]                     |  |
                   | |            | |[t1b]       |   :[rxc]                      :  :
                   | | s --------------------------------------------------------'  |
                   | |    [s2]    | :            |    \                             |
                   | |            | |[t1c]       |     \[rxd]                       :
                   | :            | |   s ------------------------------------------'
                   | tx.send(s)   | t1.send(s)   |       \   [s1]
                   |         |    |         |    |        \
                   |         |    |         '------.       \
                   |         |    |              | |[m_s1]  +
                   |         '---------------------+        |[rxe]
                   |              |  [m_s2]      |  \       :
                   |              |              | Ok(s) = rx.recv()
                   |              |              | println!("A1 received {:?}", s)
+------------------+--------------+--------------+
|
[move_rx]: stroke="orange" stroke-width="10"
[m_t1]:  stroke="orange" stroke-width="10"
[m_t2]: stroke="orange" stroke-width="10"
[m_s1]: stroke="blue" stroke-width="10"
[m_s2]: stroke="blue" stroke-width="10"
[rxa]: stroke="blue"
[rxb]: stroke="blue"
[rxc]: stroke="blue"
[rxd]: stroke="blue", stroke-dasharray="5,2"
[rxe]: stroke="blue"
[txa]: stroke="blue"
[txb]: stroke="blue"
[t1a]: stroke="blue"
[t1b]: stroke="blue"
[t1c]: stroke="blue"
[t2a]: stroke="blue"
[temp_data]: stroke="black"
[d1]: stroke="black"
[d2]: stroke="black"
[s1]: stroke="black"
[s2]: stroke="black"
```

>- `rx`{.rust}, `t1`{.rust}, `tx`{.rust} still moved from one thread to another.
>- `data`{.rust} is shared reference to character slice: freely copyable
>- `s`'s are subslices `&data[0..4]`{.rust} + `&data[2..6]`{.rust} (overlap is safe!)

## Sending and sharing intertwine

Can send `&`-references and `&mut`-references

>- `&`-refs copy (as usual).
>- `&mut`-refs obey move semantics when sent (as usual)

Examples

```rust
fn send_ref_i32(arg: &i32) {
    rayon::scope(move |s| {
        s.spawn(move |_s| println!("arg: {:?}", arg));
    });
}

fn send_ref_vec(arg: &Vec<i32>) {
    rayon::scope(move |s| {
        s.spawn(move |_s| println!("arg: {:?}", arg));
    });
}

fn send_mut_vec(arg: &mut Vec<i32>) {
    rayon::scope(move |s| {
        s.spawn(move |_s| println!("arg: {:?}", arg));
    });
}
```

So far so good

## "Can't always get what you want ..."

Can send `&`-references and `&mut`-references ... if data synchronized!

``` {.rust .compile_error}
fn send_ref_to_cell(arg: &Cell<i32>) {
    rayon::scope(move |s| {
        s.spawn(move |_s| println!("arg: {:?}", arg));
    });
}
```

. . .

``` {.terminal}
error[E0277]: the trait bound `Cell<i32>: Sync` is not satisfied
   --> src/a00.rs:547:5
    |
547 |     rayon::scope(move |s| {
    |     ^^^^^^^^^^^^ `Cell<i32>` cannot be shared between threads safely
    |
    = help: the trait `Sync` is not implemented for `Cell<i32>`
    = note: required because of the requirements on the impl of `Send` for `&Cell<i32>`
    = note: required because it appears within the type `[closure@src/a00.rs:547:18: 549:6 arg:&Cell<i32>]`
    = note: required by `rayon::scope`
```

. . .

"but [...] you get what you need"

`Cell<T>`{.rust}: *unsynchronized* mutation; incompatible with `Sync`.

(Synchronous alternatives include `AtomicUsize`{.rust}, `Mutex<T>`)

## The `Send`{.rust} traits

`Send`{.rust}: focused on ownership transfer

. . .

But we already know that move semantics alone does not suffice

(We need our references!)

## The `Send`{.rust} and `Sync`{.rust} traits

>- `Send`{.rust} and `Sync`{.rust} control cross-thread capabilities
>- `T: Send`{.rust} implies ownership of `T`{.rust} can be tranferred across threads
>- `T: Sync`{.rust} implies a reference to `T`{.rust} (e.g. `&T`{.rust}, `Arc<T>`{.rust})
   can be shared across threads
>- `Send`{.rust} enables Message Passing style concurrency, via channels
>- `Sync`{.rust} enables Shared State style concurrency;
   only `T`{.rust} with synchronized access is allowed
>- Rust compiler *automatically* marks types as `Send`{.rust} or `Sync`{.rust},
   based on a recursive analysis of their structure.
>- Data-structure designer can opt out of above analysis. (If
   doing `unsafe`{.rust} stuff, they may need to do so for soundness!)

   See also: [`https://www.ralfj.de/blog/2017/06/09/mutexguard-sync.html`][mutex-guard]

[mutex-guard]: https://www.ralfj.de/blog/2017/06/09/mutexguard-sync.html


## Rust as enabler of individuals {.big_text .center}

### From "mere script programmer"

### to "lauded systems hacker"

. . .

> Programming in Rust has made me look at C++ code in a whole new light

. . .

> After experiencing Rust, I dread looking at code from prior projects ... I will now see how riddled with races it was

## Thanks

<div class="no_border logo">
![][Rust Logo]
<div>

------------------- -----------------
`www.rust-lang.org` Hack Without Fear
------------------- -----------------

[Rust Logo]: Rust_programming_language_black_logo.svg
